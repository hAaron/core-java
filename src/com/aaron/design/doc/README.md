**字符集编码统一 UTF-8**
# 设计模式 com.aaron.design 设计模式的分类 #

设计模式分为三大类：

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、调停者模式、解释器模式。

# 设计模式的六大原则 #

## 1、开闭原则（Open Close Principle） ##

开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

## 2、里氏代换原则（Liskov Substitution Principle） ##

里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科

## 3、依赖倒转原则（Dependence Inversion Principle） ##

这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。

## 4、接口隔离原则（Interface Segregation Principle） ##

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。

## 5、迪米特法则（最少知道原则）（Demeter Principle） ##

为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。

## 6、合成复用原则（Composite Reuse Principle） ##

原则是尽量使用合成/聚合的方式，而不是使用继承。

## 总结 ##

单例模式 com.aaron.design.singleton

> 意图：所谓单例就是所有的请求都用一个对象来处理，比如我们常用的service和dao层的对象通常都是单例的，而多例则指每个请求用一个新的对象来处理，比如action;

观察者模式 com.aaron.design.observer

> 意图：观察者模式需要有一个主题，还有一个或多个观察者。 在主题类中有一个观察者的集合。当调用主题类的某些方法时，自动循环这个集合，调用观察者的方法。
> 
> 定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时会通知所有的观察者对象，使他们能够自动更新自己

适配器模式 com.aaron.design.adapter

> 意图：不改变原有接口，却还能使用新接口的功能。将一个类的接口转换成客户希望的另外一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作 。适配器模式有2种，第一种是“面向类的适配器模式”，第二种是“面向对象的适配器模式”。
> 
> 1.面向类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可
> 
> 2.面向对象的适配器模式:对象的适配器模式 当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个对象适配类，持有原类的一个实例，在对象适配类的方法中，调用实例的方法就行。

迭代器模式 com.aaron.design.iterator

> 意图：提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部表示
> 
> 迭代器模式的优点有：
> 简化了遍历方式，对于对象集合的遍历，还是比较麻烦的，对于数组或者有序列表，我们尚可以通过游标来取得，但用户需要在对集合了解很清楚的前提下，自行遍历对象，但是对于hash表来说，用户遍历起来就比较麻烦了。而引入了迭代器方法后，用户用起来就简单的多了。
> 可以提供多种遍历方式，比如说对有序列表，我们可以根据需要提供正序遍历，倒序遍历两种迭代器，用户用起来只需要得到我们实现好的迭代器，就可以方便的对集合进行遍历了。
> 封装性良好，用户只需要得到迭代器就可以遍历，而对于遍历算法则不用去关心。
> 
> 迭代器模式的缺点：
> 对于比较简单的遍历（像数组或者有序列表），使用迭代器方式遍历较为繁琐，大家可能都有感觉，像ArrayList，我们宁可愿意使用for循环和get方法来遍历集合。

装饰器模式 com.aaron.design.decorator

> 意图：在运行时组合操作的新变化。通过装饰器模式可以在运行时扩充一个类的功能。增加一个修饰类包裹原来的类，包裹的方式一般是通过在将原来的对象作为修饰类的构造函数的参数。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用原来的类中的方法。修饰类必须和原来的类有相同的接口。（AOP的简单实现）

> 优缺点：

> 1.装饰者类反应出被装饰的组件类型
>
> 2.装饰者类可以在被装饰者的行为前面或后面加上自己的行为，甚至取代被装饰者的行为，达到特定的目的
> 
> 3.可以用无数个装饰者包装一个组件，装饰者类会导致设计中出现许多小对象，过度使用会让程序变的复杂
> 
> 4.装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型
   
    装饰器模式的基本角色：
    被装饰类接口： Component
    具体被装饰类： ConcreteComponent
    装饰器抽象类： Decorator, 这个类可有可无具体看情况。
    具体的装饰器类： ConcreteDecorator， 具体装饰器类实现真正的动态添加类的功能的作用。
    
代理模式 com.aaron.design.proxy

> 意图：为其他对象提供代理，以控制对该对象的访问
> 
> 静态代理：所谓静态代理即在程序运行前代理类就已经存在，也就是说我们编写代码的时候就已经把代理类的代码写好了，而动态代理则是在程序运行时自动生成代理类。
> 
> 动态代理：通过看静态代理可以动态扩展我们的对象，但是有个问题，在我们进行方法扩展的时候，比如我们的日志功能：每个前面都得写第一步、第二步。如果我们要再一些其他的东西，比如权限校验、代码说明，一个两个方法还好，万一方法成百个呢，那我们岂不是要累死。这就是动态代理要解决的问题，只需要写一次就可以。这里主要将额外的方法放在了代理类中实现(AOP)，不改变原来的代码结构

    一个典型的动态代理创建对象过程可分为以下四个步骤：
    1、通过实现InvocationHandler接口创建自己的调用处理器 IvocationHandler handler = new InvocationHandlerImpl(...);
    2、通过为Proxy类指定ClassLoader对象和一组interface创建动态代理类
    Class clazz = Proxy.getProxyClass(classLoader,new Class[]{...});
    3、通过反射机制获取动态代理类的构造函数，其参数类型是调用处理器接口类型
    Constructor constructor = clazz.getConstructor(new Class[]{InvocationHandler.class});
    4、通过构造函数创建代理类实例，此时需将调用处理器对象作为参数被传入
    Interface Proxy = (Interface)constructor.newInstance(new Object[] (handler));
    为了简化对象创建过程，Proxy类中的newInstance方法封装了2~4，只需两步即可完成代理对象的创建。
    生成的ProxySubject继承Proxy类实现Subject接口，实现的Subject的方法实际调用处理器的invoke方法，而invoke方法利用反射调用的是被代理对象的的方法（Object result=method.invoke(proxied,args)）

外观模式 com.aaron.design.facade

意图：在于降低系统的复杂程度。从很大程度上提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。

	Facade模式有下面一些优点：
	1、它对客户屏蔽子系统组件，因而减少了客户处理的对象的数目并使得子系统使用起来更加方便。
	2、它实现了子系统与客户之间的松耦合关系，而子系统内部的功能组件往往是紧耦合的。
	　松耦合关系使得子系统的组件变化不会影响到它的客户。Facade模式有助于建立层次结构系统，也有助于对对象之间的依赖关系分层。Facade模式可以消除复杂的循环依赖关系。这一点在客户程序与子系统是分别实现的时候尤为重要。
	　在大型软件系统中降低编译依赖性至关重要。在子系统类改变时，希望尽量减少重编译工作以节省时间。用Facade可以降低编译依赖性，限制重要系统中较小的变化所需的重编译工作。Facade模式同样也有利于简化系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。
	3、如果应用需要，它并不限制它们使用子系统类。因此你可以在系统易用性和通用性之间加以选择。

工厂方法模式 com.aaron.design.factorymethod

	组成：
	1)抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。
	2)具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。
	3)抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。
	4)具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。

抽象工厂模式 com.aaron.design.factory.abstracts

> 1.简单工厂模式是由一个具体的类去创建其他类的实例，父类是相同的，父类是具体的。 
> 2.工厂方法模式是有一个抽象的父类定义公共接口，子类负责生成具体的对象，这样做的目的是将类的实例化操作延迟到子类中完成。 
> 3.抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定他们具体的类。它针对的是有多个产品的等级结构。而工厂方法模式针对的是一个产品的等级结构。

构建者模式 com.aaron.design.builder
> 
> 意图:将类的构建逻辑转移到类的实例化外部。建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。所以与工程模式的区别就是：工厂模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。因此，是选择工厂模式还是建造者模式，依实际情况而定。

原型模式 com.aaron.design.prototype

意图：通过复制一个现有的对象来生成新的对象，而不是通过实例化的方式。

	一个原型类，只需要实现Cloneable接口，覆写clone方法，此处clone方法可以改成任意的名称，
	因为Cloneable接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是super.clone()这句话，
	super.clone()调用的是Object的clone()方法，而在Object类中，clone()是native的
	对象深、浅复制的概念：
	浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。
	深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。

桥接模式 com.aaron.design.bridge

> 意图：将抽象部分与实现部分分离，使它们都可以独立的变化。

	效果及实现要点：
	1．Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。
	2．所谓抽象和实现沿着各自维度的变化，即“子类化”它们，得到各个子类之后，便可以任意它们，从而获得不同路上的不同汽车。
	3．Bridge模式有时候类似于多继承方案，但是多继承方案往往违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差。Bridge模式是比多继承方案更好的解决方法。
	4．Bridge模式的应用一般在“两个非常强的变化维度”，有时候即使有两个变化的维度，但是某个方向的变化维度并不剧烈——换言之两个变化不会导致纵横交错的结果，并不一定要使用Bridge模式。

合成模式 com.aaron.design.composite

> 意图：为了保证客户端调用单对象与组合对象的一致性。属于对象的结构模式，有时又叫做“部分——整体”模式。合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式可以使客户端将单纯元素与复合元素同等看待。

	涉及到三个角色：
	抽象构件(Component)角色：这是一个抽象角色，它给参加组合的对象定义出公共的接口及其默认行为，可以用来管理所有的子对象。合成对象通常把它所包含的子对象当做类型为Component的对象。在安全式的合成模式里，构件角色并不定义出管理子对象的方法，这一定义由树枝构件对象给出。
	树叶构件(Leaf)角色：树叶对象是没有下级子对象的对象，定义出参加组合的原始对象的行为。
	树枝构件(Composite)角色：代表参加组合的有下级子对象的对象。树枝构件类给出所有的管理子对象的方法，如add()、remove()以及getChild()。

合成模式的实现根据所实现接口的区别分为两种形式，分别称为安全式和透明式。

享元模式 com.aaron.design.flyweight

> 意图：享元模式是对象的结构模式。享元模式以共享的方式高效地支持大量的细粒度对象。

	享元模式在一般的项目开发中并不常用，而是常常应用于系统底层的开发，以便解决系统的性能问题。	
	比如：Java中的String类型就是使用了享元模式。
	到底系统需要满足什么样的条件才能使用享元模式。对于这个问题，总结出以下几点： 
	1、一个系统中存在着大量的细粒度对象；
	
	2、这些细粒度对象耗费了大量的内存。 
	
	3、这些细粒度对象的状态中的大部分都可以外部化； 
	
	4、这些细粒度对象可以按照内蕴状态分成很多的组，当把外蕴对象从对象中剔除时，每一个组都可以仅用一个对象代替。 
	
	5、软件系统不依赖于这些对象的身份，换言之，这些对象可以是不可分辨的。
	
	满足以上的这些条件的系统可以使用享元对象。最后，使用享元模式需要维护一个记录了系统已有的所有享元的哈希表，也称之为对象池，而这也需要耗费一定的资源。因此，应当在有足够多的享元实例可供共享时才值得使用享元模式。

享元模式可以分成单纯享元模式和复合享元模式两种形式。

单纯享元模式所涉及到的角色如下：
	
	抽象享元(Flyweight)角色 ：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。
	
	具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。
	
	享元工厂(FlyweightFactory)角色 ：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个合适的享元对象。

复合享元模式：在单纯享元模式中，所有的享元对象都是单纯享元对象，也就是说都是可以直接共享的。还有一种较为复杂的情况，将一些单纯享元使用合成模式加以复合，形成复合享元对象。这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。

复合享元角色所涉及到的角色如下：

	抽象享元(Flyweight)角色 ：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。

	具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。

	复合享元(ConcreteCompositeFlyweight)角色 ：复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称作不可共享的享元对象。

	享元工厂(FlyweightFactory)角色 ：本角 色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有 一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个 合适的享元对象。

享元模式的优缺点
> 享元模式的优点在于它大幅度地降低内存中对象的数量。但是，它做到这一点所付出的代价也是很高的
> 
> 享元模式使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。
> 
> 享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。

策略模式  com.aaron.design.strategy

意图：将可互换的方法封装在各自独立的类中，并且让每个方法实现一个公共的操作。

这个模式涉及到三个角色：

	环境(Context)角色：持有一个Strategy的引用。
	
	抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。
	
	具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。

策略模式的优点

　　（1）策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。

　　（2）使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。

策略模式的缺点

　　（1）客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。

　　（2）由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。

模板方法模式 com.aaron.design.templatemethod

意图：在一个方法里实现一个算法，并推迟定义算法中的某些步骤，从而让其他类重新定义它们(排序算法)

这里涉及到两个角色：

　　抽象模板(Abstract Template)角色有如下责任：

	定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。
	
	定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。

　　具体模板(Concrete Template)角色又如下责任：

	实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。
	
	每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。

责任链模式 com.aaron.design.chainofresponsibility

意图：责任链模式是一种对象的行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。(tomcat中filter的实现 Chain)

责任链模式涉及到的角色如下所示：

	抽象处理者(Handler)角色：定义出一个处理请求的接口。如果需要，接口可以定义 出一个方法以设定和返回对下家的引用。这个角色通常由一个Java抽象类或者Java接口实现。上图中Handler类的聚合关系给出了具体子类对下家的引用，抽象方法handleRequest()规范了子类处理请求的操作。
	
	具体处理者(ConcreteHandler)角色：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家。

命令模式 com.aaron.design.command

解释：命令模式属于对象的行为模式。命令模式又称为行动(Action)模式或交易(Transaction)模式。命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。(录音机是典型的命令模式,录音机按键把客户端与录音机的操作细节分割开来。)

命令模式涉及到五个角色，它们分别是：

	　　● 客户端(Client)角色：创建一个具体命令(ConcreteCommand)对象并确定其接收者。
	
	　　● 命令(Command)角色：声明了一个给所有具体命令类的抽象接口。
	
	　　● 具体命令(ConcreteCommand)角色：定义一个接收者和行为之间的弱耦合；实现execute()方法，负责调用接收者的相应操作。execute()方法通常叫做执行方法。
	
	　　● 请求者(Invoker)角色：负责调用命令对象执行请求，相关的方法叫做行动方法。
	
	　　● 接收者(Receiver)角色：负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。

命令模式的优点

	　　● 更松散的耦合
	　　命令模式使得发起命令的对象——客户端，和具体实现命令的对象——接收者对象完全解耦，也就是说发起命令的对象完全不知道具体实现对象是谁，也不知道如何实现。
	
	　　● 更动态的控制
	　　命令模式把请求封装起来，可以动态地对它进行参数化、队列化和日志化等操作，从而使得系统更灵活。
	
	　　● 很自然的复合命令
	　　命令模式中的命令对象能够很容易地组合成复合命令，也就是宏命令，从而使系统操作更简单，功能更强大。
	
	　　● 更好的扩展性
	　　由于发起命令的对象和具体的实现完全解耦，因此扩展新的命令就很容易，只需要实现新的命令对象，然后在装配的时候，把具体的实现对象设置到命令对象中，然后就可以使用这个命令对象，已有的实现完全不用变化。

备忘录模式 com.aaron.design.memento

解释：备忘录模式又叫做快照模式(Snapshot Pattern)或Token模式，是对象的行为模式。备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捕捉(Capture)住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。备忘录模式常常与命令模式和迭代子模式一同使用。

所谓“自述历史”模式(History-On-Self Pattern)实际上就是备忘录模式的一个变种。在备忘录模式中，发起人(Originator)角色、负责人(Caretaker)角色和备忘录(Memento)角色都是独立的角色。虽然在实现上备忘录类可以成为发起人类的内部成员类，但是备忘录类仍然保持作为一个角色的独立意义。在“自述历史”模式里面，发起人角色自己兼任负责人角色。

备忘录模式所涉及的角色有三个：备忘录(Memento)角色、发起人(Originator)角色、负责人(Caretaker)角色。

备忘录角色有如下责任：

　　（1）将发起人（Originator）对象的内部状态存储起来。

　　（2）备忘录可以保护其内容不被发起人（Originator）对象之外的任何对象所读取。

发起人角色有如下责任：

　　（1）创建一个含有它当前的内部状态的备忘录对象。

　　（2）使用备忘录对象存储其内部状态。

　　客户端角色有负责保存备忘录对象的责任。

状态模式 com.aaron.design.state

解释：又称状态对象模式（Pattern of Objects for States），状态模式是对象的行为模式。状态模式允许一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样。用一句话来表述，状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变

状态模式所涉及到的角色有：

	环境(Context)角色，也成上下文：定义客户端所感兴趣的接口，并且保留一个具体状态类的实例。这个具体状态类的实例给出此环境对象的现有状态。
	
	抽象状态(State)角色：定义一个接口，用以封装环境（Context）对象的一个特定的状态所对应的行为。
	
	具体状态(ConcreteState)角色：每一个具体状态类都实现了环境（Context）的一个状态所对应的行为。

访问者模式 com.aaron.design.visitor

解释：访问者模式是对象的行为模式。访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保持不变。

访问者模式涉及到的角色如下：

　　●　　抽象访问者(Visitor)角色：声明了一个或者多个方法操作，形成所有的具体访问者角色必须实现的接口。

　　●　　具体访问者(ConcreteVisitor)角色：实现抽象访问者所声明的接口，也就是抽象访问者所声明的各个访问操作。

　　●　　抽象节点(Node)角色：声明一个接受操作，接受一个访问者对象作为一个参数。

　　●　　具体节点(ConcreteNode)角色：实现了抽象节点所规定的接受操作。

　　●　　结构对象(ObjectStructure)角色：有如下的责任，可以遍历结构中的所有元素；如果需要，提供一个高层次的接口让访问者对象可以访问每一个元素；如果需要，可以设计成一个复合对象或者一个聚集，如List或Set。

访问者模式的优点
	
	好的扩展性：能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。
	
	好的复用性：可以通过访问者来定义整个对象结构通用的功能，从而提高复用程度。
	
	分离无关行为：可以通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。

访问者模式的缺点

	对象结构变化很困难：不适用于对象结构中的类经常变化的情况，因为对象结构发生了改变，访问者的接口和访问者的实现都要发生相应的改变，代价太高。
	
	破坏封装：访问者模式通常需要对象结构开放内部数据给访问者和ObjectStructrue，这破坏了对象的封装性。

解释器模式 com.aaron.design.interpreter

解释：解释器模式是类的行为模式。给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。

　模式所涉及的角色如下所示：

	（1）抽象表达式(Expression)角色：声明一个所有的具体表达式角色都需要实现的抽象接口。这个接口主要是一个interpret()方法，称做解释操作。
	
	（2）终结符表达式(Terminal Expression)角色：实现了抽象表达式角色所要求的接口，主要是一个interpret()方法；文法中的每一个终结符都有一个具体终结表达式与之相对应。比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。
	
	（3）非终结符表达式(Nonterminal Expression)角色：文法中的每一条规则都需要一个具体的非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，“+"就是非终结符，解析“+”的解释器就是一个非终结符表达式。
	
	（4）环境(Context)角色：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。

调停者模式 com.aaron.design.mediator

解释：调停者模式是对象的行为模式。调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用。从而使它们可以较松散地耦合。当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其他的一些对象之间的相互作用。从而保证这些相互作用可以彼此独立地变化。

调停者模式包括以下角色：

	抽象调停者(Mediator)角色：定义出同事对象到调停者对象的接口，其中主要方法是一个（或多个）事件方法。
	
	具体调停者(ConcreteMediator)角色：实现了抽象调停者所声明的事件方法。具体调停者知晓所有的具体同事类，并负责具体的协调各同事对象的交互关系。
	
	抽象同事类(Colleague)角色：定义出调停者到同事对象的接口。同事对象只知道调停者而不知道其余的同事对象。
	
	具体同事类(ConcreteColleague)角色：所有的具体同事类均从抽象同事类继承而来。实现自己的业务，在需要与其他同事通信的时候，就与持有的调停者通信，调停者会负责与其他的同事交互。

调停者模式的优点

　　●　松散耦合

　　调停者模式通过把多个同事对象之间的交互封装到调停者对象里面，从而使得同事对象之间松散耦合，基本上可以做到互补依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那样“牵一处而动全身”了。

　　●　集中控制交互

　　多个同事对象的交互，被封装在调停者对象里面集中管理，使得这些交互行为发生变化的时候，只需要修改调停者对象就可以了，当然如果是已经做好的系统，那么就扩展调停者对象，而各个同事类不需要做修改。

　　●  多对多变成一对多

　　没有使用调停者模式的时候，同事对象之间的关系通常是多对多的，引入调停者对象以后，调停者对象和同事对象的关系通常变成双向的一对多，这会让对象的关系更容易理解和实现。

调停者模式的缺点

　　调停者模式的一个潜在缺点是，过度集中化。如果同事对象的交互非常多，而且比较复杂，当这些复杂性全部集中到调停者的时候，会导致调停者对象变得十分复杂，而且难于管理和维护。


